local M = {}

local api = vim.api
local ui = require 'rafta.view.ui'

-- Populated/provided during setup by view. This is done to keep a single
-- namespace_id generated by view consistent for both highlight groups and
-- extmarks without circular dependencies.
local namespace_id = 0

---@class rafta.view.extmarks.set
---@field main integer --containing main hl_group and virt_text
---@field short_id integer -- concealing the short_id at the start of every line
---@field state integer -- visually replacing the state character with an icon

M.setup = function(ns_id)
	namespace_id = ns_id
end


---@param task rafta.util.task-provider
M.tags = function(task)
	-- Check if task has data field
	local tags = task.tags()
	local count = (tags and #tags) or 0
	if count ~= 0 then
		return {
			ui.icons.info.tags .. ' ' .. tostring(count) .. ' ',
			ui.colors.info.tags
		}
	end
	return nil
end

---@param task rafta.util.task-provider
M.reccuring = function(task)
	local recurrence = task.recurrence()
	if recurrence and recurrence.active then
		return {
			ui.icons.info.recurring .. ' ',
			ui.colors.info.recurring
		}
	end
	return nil
end

-- TODO: perhaps align extmarks in a table fashion by spacing fields when
-- they aren't there
M.extmarks = function(task)
	local marks = {}
	-- TODO: due/do for which I didn't want to bother with Jan 1 1970 rn...
	local tags_mark = M.tags(task)
	local recurring_mark = M.reccuring(task)

	if tags_mark then table.insert(marks, tags_mark) end
	if recurring_mark then table.insert(marks, recurring_mark) end
	return marks
end

---@param task rafta.util.task-provider
M.resolve_hl_group = function(task)
	local state = (task.state() or 'unspecified'):lower()
	local priority = task.priority() or 0
	if state == 'done' and ui.colors.completed_override then
		return ui.colors.completed_override
	elseif priority == 0 then
		return ui.colors.text.no_priority
	else
		return ui.colors.text.priority[priority]
	end
end

---@param task rafta.util.task-provider
M.resolve_conceal_state = function(task)
	local state = (task.state() or 'unspecified'):lower()
	return ui.icons.state[state]
end

---@param bufnr integer
---@param line integer
---@param task rafta.util.task-provider
---@param extmark_set rafta.view.extmarks.set
M.set = function(bufnr, line, task, extmark_set)
	if namespace_id == 0 then return extmark_set end
	extmark_set = extmark_set or {}

	-- Get the current line to compute end_col
	local lines = api.nvim_buf_get_lines(bufnr, line, line + 1, false)
	local line_text = lines[1] or ""
	local end_col = #line_text

	-- Resolve highlight group based on priority/state
	local hl_group = M.resolve_hl_group(task)

	-- Set or update the extmark covering the full line
	extmark_set.main = api.nvim_buf_set_extmark(bufnr, namespace_id, line, 0, {
		id = extmark_set.main,           -- existing id or nil -> new extmark created
		end_row = line,                  -- single line
		end_col = end_col,               -- full line
		hl_group = hl_group,             -- line highlight based on priority
		virt_text = M.extmarks(task),    -- optional icons/tags
		virt_text_pos = 'eol_right_align', -- keep them at end
	})

	extmark_set.short_id = api.nvim_buf_set_extmark(bufnr, namespace_id, line, 0, {
		id = extmark_set.short_id,
		end_row = line,
		end_col = 5,
		conceal = '',
	})

	extmark_set.state = api.nvim_buf_set_extmark(bufnr, namespace_id, line, 6, {
		id = extmark_set.state,
		hl_group = hl_group,
		end_row = line,
		end_col = 7,
		conceal = M.resolve_conceal_state(task),
	})

	return extmark_set
end

return M
