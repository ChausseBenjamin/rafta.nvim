local M = {}

local api = vim.api
local ui = require 'rafta.view.ui'

-- Populated/provided during setup by view. This is done to keep a single
-- namespace_id generated by view consistent for both highlight groups and
-- extmarks without circular dependencies.
local namespace_id = 0

M.setup = function(ns_id)
	namespace_id = ns_id
end


M.tags = function(task)
	-- Check if task has data field
	if task.data and task.data.tags and #task.data.tags ~= 0 then
		return {
			ui.icons.info.tags .. ' ' .. tostring(#task.data.tags) .. ' ',
			ui.colors.info.tags
		}
	end
	return nil
end

M.reccuring = function(task)
	if task.data and task.data.recurrence and task.data.recurrence.active == true then
		return {
			ui.icons.info.recurring .. ' ',
			ui.colors.info.recurring
		}
	end
	return nil
end

M.set = function(bufnr, line, task, extmark_id)
	local marks = {}
	-- TODO: due/do for which I didn't want to bother with Jan 1 1970 rn...
	local tags_mark = M.tags(task)
	local recurring_mark = M.reccuring(task)

	if tags_mark then table.insert(marks, tags_mark) end
	if recurring_mark then table.insert(marks, recurring_mark) end

	-- safeguard so extmarks stay owned by the plugin
	if namespace_id ~= 0 and #marks > 0 then
		-- TODO: nil checks to esure each extmark is enabled
		-- TODO: perhaps align extmarks in a table fashion by spacing fields when
		-- they aren't there
		extmark_id = api.nvim_buf_set_extmark(
			bufnr, namespace_id, line, 0, {
				id = extmark_id, -- nil is provided -> new one gets be created and returned
				virt_text = marks,
				virt_text_pos = 'eol_right_align',
			})
	end

	return extmark_id
end


return M
